/* eslint-disable @typescript-eslint/semi */
/* eslint-disable @typescript-eslint/quotes */
/* eslint-disable import/order */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable no-param-reassign */
/* eslint-disable prefer-const */
/* eslint-disable max-len */
/* eslint-disable no-plusplus */
/* eslint-disable no-console */
/* eslint-disable import/no-cycle */
import { Container, Grid, Button, Box, Title, Flex, Mark, createStyles } from '@mantine/core';
import { useDebouncedState, useElementSize, useIdle } from '@mantine/hooks';
import { RichTextEditor, Link } from '@mantine/tiptap';
import { useEditor } from '@tiptap/react';
import Text from '@tiptap/extension-text';
import React, { createContext, useEffect, useRef, useState, useContext } from 'react';
import { AnalyzeRequest } from 'ts-pres';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import ResultDetailPanel from './ResultsDetailPanel';
import SettingsPane from './SettingsPane';
import { RecognizerResultWithSubstring } from '../../pages/api/neranalysis';
import Document from '@tiptap/extension-document';
import Paragraph from '@tiptap/extension-paragraph';
import EntityButtonExtension from './tiptap_EntityButtonExtension';
import EntityTextExtension from './tiptap_EntityTextExtension';
import LLMChatInputBox from './LLMChatInputBox';
import LLMChatOutputBox from './LLMChatOutputBox';
import { ParseOptions } from '@tiptap/pm/model';
import StarterKit from '@tiptap/starter-kit';

const content =
  '<i>Welcome</i> to <node-view contenteditable="false">text</node-view> the playground where you can check entity recognition and synthesis.  Select from the example texts or enter your own. "My credit card number is 4095-2609-9393-4932 and my crypto wallet id is 16Yeky6GMjeNkAiNcBY7ZhrLoMSgg1BoyZ.";';
interface AnalysisRequestSettingsContextProps {
  analysisRequestSettings: AnalyzeRequest;
  setAnalysisRequestSettings: React.Dispatch<React.SetStateAction<AnalyzeRequest>>;
}

const AnalysisRequestSettingsContext = createContext<AnalysisRequestSettingsContextProps>(
  {} as AnalysisRequestSettingsContextProps
);

export function useAnalysisRequestSettings(): AnalysisRequestSettingsContextProps {
  return useContext(AnalysisRequestSettingsContext);
}

// Create a function that iterates through the RecognizerResultWithSubstring[], selects the substring, gets its content, then replaces it with the content wrapped in an entity tag.

function markEntitiesInText(
  originalText: string,
  response: RecognizerResultWithSubstring[]
): string {
  console.log('RESPONSE!', response);
  for (let i = 0; i < response.length; i++) {
    const { substring, entityType } = response[i];
    console.log('substring', substring);
    console.log('entityType', entityType);
    // Wrap the entity with the <mark> tag and include the entity type
    const escapedSubstring = substring.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    let markedSubstring = `<entity type="${entityType}">${substring}</entity>`;
    // If the last character in substring is whitespace, place a whitespace at the end of the markedSubstring
    if (substring[substring.length - 1] === ' ') {
      markedSubstring.concat(' ');
    }
    console.log('markedSubstring', markedSubstring);

    // Create a new RegExp object for the escaped substring
    const regex = new RegExp(escapedSubstring, 'g');
    // Replace the substring in the original text with the marked entity
    originalText = originalText.replace(regex, markedSubstring);
    console.log('new substring', originalText);
  }
  return originalText;
}

export default function Playground() {
  const idle = useIdle(1000, { events: ['keypress'] });
  // Create the input editor
  // const [value, setValue] = useDebouncedState('', 200);
  const [liveUpdate, setLiveUpdate] = useState(false);
  // The queryClient lets us invalidate the prior request so we can refetch the analysis.
  const queryClient = useQueryClient();
  // This is storing all the analysis request state. Mutator is being passed to settings via Context.  AnalyzeRequest is generated by the Presidio OpenAPI defs.
  const [analysisRequestSettings, setAnalysisRequestSettings] = useState<AnalyzeRequest>({
    text: content,
    language: 'en',
    scoreThreshold: 0.35,
  });
  const inputEditor = useEditor({
    extensions: [Document, Text, Paragraph, StarterKit, EntityTextExtension],
    content,
    onUpdate({ editor }) {
      if (!liveUpdate) return;
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      if (isFetching) return;
      analysisRequestSettings.text = inputEditor?.getText() || '';
      queryClient.invalidateQueries(['analyze']);
    },
  });

  const handleSubmit = () => {
    console.log(JSON.stringify(analysisRequestSettings));
    inputEditor?.commands.setTextSelection({ from: 0, to: 15 });
    const { view, state } = inputEditor!;
    const { from, to } = view.state.selection;
    const text = state.doc.textBetween(from, to);
    console.log('inner text', text);
    inputEditor?.commands.insertContent(`<entity type="UNKNOWN">${text}</entity>`);
    // console.log(inputEditor?.commands.insertContent('test'));
    analysisRequestSettings.text = inputEditor?.getHTML() || '';

    // queryClient.invalidateQueries(['analyze']);
  };

  // Create the result editor
  const resultEditor = useEditor({
    extensions: [Document, Text, Paragraph, EntityButtonExtension],
    content: '',
  });

  // This function is being stored in context to pass down to settings so it can load example texts
  function setEditorContent(text: string) {
    inputEditor?.commands.setContent(text, false, { preserveWhitespace: true });
  }

  // This is our REST call to the Next.js API route which calls the Presidio API.  RecognizerResultWithSubstring[] is a type we created to extend
  // Presidio's RecognizerResultWithAnalysis OpenAPI definition, and add the full substring.
  const sendAnalyzeRequest = (
    requestSettings: AnalyzeRequest
  ): Promise<RecognizerResultWithSubstring[]> => {
    console.log('sending request', requestSettings);
    return fetch('/api/neranalysis', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestSettings),
    }).then((response) => response.json());
  };

  // React Query is loading up with the sendAnalyzeRequest.  Rather than manually triggering a refresh, we're using data as a useEffect trigger.  The useEffect will set the content.
  const { data, isLoading, isError, isFetching, error } = useQuery(
    ['analyze', analysisRequestSettings],
    () => sendAnalyzeRequest(analysisRequestSettings),
    {
      placeholderData: [],
    }
  );

  // This sets the editor content when data changes.  QueueMicrotask is a hack to fix a weird rendering error with TipTap/React. useTimeout() would've also worked.
  useEffect(() => {
    // analysisRequestSettings.text = editor?.getHTML() || '';
    if (data) {
      queueMicrotask(() => {
        resultEditor?.commands.setContent(
          markEntitiesInText(analysisRequestSettings.text, data),
          false,
          { preserveWhitespace: true }
        );
        inputEditor?.commands.setContent(
          markEntitiesInText(analysisRequestSettings.text, data),
          false,
          {
            preserveWhitespace: true,
          }
        );
      });
    }
  }, [data]);

  //

  //TODO: Restructure the context and memoize the children to reduce re-renders.  For now, this is fine.
  return (
    <AnalysisRequestSettingsContext.Provider
      value={{ analysisRequestSettings, setAnalysisRequestSettings }}
    >
      <Container my="md">
        <Title
          variant="gradient"
          gradient={{ from: 'indigo', to: 'cyan', deg: 45 }}
          sx={{ fontFamily: 'Greycliff CF, sans-serif' }}
          ta="center"
          fw={700}
          style={{ marginBottom: 20 }}
        >
          Welcome to the NER Playground!
        </Title>
        <Grid style={{ minHeight: 300, maxHeight: 400 }}>
          <Grid.Col span="auto">
            <LLMChatInputBox editor={inputEditor} sendChat={handleSubmit} />
          </Grid.Col>
          <Grid.Col span={5}>
            <Box
              style={{
                border: '1px solid #373a40',
                borderRadius: '5px',
                padding: '10px',
                minHeight: 300,
                maxHeight: 500,
                overflowY: 'auto',
              }}
            >
              <SettingsPane setEditorContent={setEditorContent} />
            </Box>
          </Grid.Col>
        </Grid>
        <Grid style={{ minHeight: 300, maxHeight: 500 }}>
          <Grid.Col span="auto">
            <LLMChatOutputBox resultEditor={resultEditor} />
          </Grid.Col>
          <Grid.Col span={5}>
            <Box
              style={{
                border: '1px solid #373a40',
                borderRadius: '5px',
                padding: '10px',
                minHeight: 300,
                maxHeight: 500,
                overflowY: 'auto',
              }}
            >
              <ResultDetailPanel
                analysisRequestResults={data}
                isLoading={isLoading}
                isError={isError}
                error={error}
              />
            </Box>
          </Grid.Col>
        </Grid>
      </Container>
    </AnalysisRequestSettingsContext.Provider>
  );
}
