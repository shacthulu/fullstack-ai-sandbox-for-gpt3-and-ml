/**
 * Generated by orval v6.15.0 üç∫
 * Do not edit manually.
 * Presidio
 * Context aware, pluggable and customizable PII anonymization service for text and images.
 * OpenAPI spec version: 2.0
 */
import axios from 'axios'
import type {
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery,
  useMutation
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
export type GetSupportedentitiesParams = {
/**
 * Two characters for the desired language in ISO_639-1 format
 */
language?: string;
};

export type GetRecognizersParams = {
/**
 * Two characters for the desired language in ISO_639-1 format
 */
language?: string;
};

export type DeanonymizeRequestBody = DeanonymizeRequest;

export type AnonymizeRequestBody = AnonymizeRequest;

export type AnalyzeRequestBody = AnalyzeRequest;

export interface InlineResponse422 {
  error?: string;
}

/**
 * Unprocessable Entity
 */
export type N422UnprocessableEntityResponse = InlineResponse422;

export interface InlineResponse400 {
  error?: string;
}

/**
 * Bad request
 */
export type N400BadRequestResponse = InlineResponse400;

export interface OperatorResult {
  /** Name of the used operator */
  operator?: string;
  /** Type of the PII entity */
  entity_type: string;
  /** Start index of the changed text */
  start: number;
  /** End index in the changed text */
  end: number;
  /** The new text returned */
  text?: string;
}

export interface DeanonymizeResponse {
  text?: string;
  /** Array of deanonymized entities */
  items?: OperatorResult[];
}

export interface AnonymizeResponse {
  text?: string;
  /** Array of anonymized entities */
  items?: OperatorResult[];
}

/**
 * Replace encrypted PII decrypted text
 */
export interface Decrypt {
  /** decrypt */
  type: string;
  /** Cryptographic key of length 128, 192 or 256 bits, in a string format */
  key: string;
}

/**
 * Replace with an encrypted value
 */
export interface Encrypt {
  /** encrypt */
  type: string;
  /** Cryptographic key of length 128, 192 or 256 bits, in a string format */
  key: string;
}

/**
 * The hashing algorithm
 */
export type HashHashType = typeof HashHashType[keyof typeof HashHashType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HashHashType = {
  md5: 'md5',
  sha256: 'sha256',
  sha512: 'sha512',
} as const;

/**
 * Replace with hashed value
 */
export interface Hash {
  /** hash */
  type: string;
  /** The hashing algorithm */
  hash_type?: HashHashType;
}

/**
 * Replace with a given character
 */
export interface Mask {
  /** mask */
  type: string;
  /** The replacement character */
  masking_char: string;
  /** The amount of characters that should be replaced */
  chars_to_mask: number;
  /** Whether to mask the PII from it's end */
  from_end?: boolean;
}

/**
 * Replace with an empty string
 */
export interface Redact {
  /** redact */
  type: string;
}

/**
 * Replace with a given value
 */
export interface Replace {
  /** replace */
  type: string;
  /** The string to replace with */
  new_value: string;
}

/**
 * The supported PII entity types.
 */
export type EntityTypes = string;

export interface Pattern {
  /** Name of regular expression pattern */
  name?: string;
  /** Regex pattern string */
  regex?: string;
  /** Detection confidence of this pattern (0.01 if very noisy, 0.6-1.0 if very specific) */
  score?: number;
}

/**
 * A regular expressions or deny-list based recognizer
 */
export interface PatternRecognizer {
  /** Name of recognizer */
  name?: string;
  /** Language code supported by this recognizer */
  supported_language?: string;
  /** List of type Pattern containing regex expressions with additional metadata. */
  patterns?: Pattern[];
  /** List of words to be returned as PII if found. */
  deny_list?: string[];
  /** List of words to be used to increase confidence if found in the vicinity of detected entities. */
  context?: string[];
  /** The name of entity this ad hoc recognizer detects */
  supported_entity?: string;
}

export interface AnalysisExplanation {
  /** Name of recognizer that made the decision */
  recognizer?: string;
  /** name of pattern (if decision was made by a PatternRecognizer) */
  pattern_name?: string;
  /** Regex pattern that was applied (if PatternRecognizer) */
  pattern?: string;
  /** Recognizer's confidence in result */
  original_score?: number;
  /** The PII detection score */
  score?: number;
  /** Free text for describing a decision of a logic or model */
  textual_explanation?: string;
  /** Difference from the original score */
  score_context_improvement?: number;
  /** The context word which helped increase the score */
  supportive_context_word?: string;
  /** Result of a validation (e.g. checksum) */
  validation_result?: number;
}

export type RecognizerResultWithAnaysisExplanationAllOf = {
  analysis_explanation?: AnalysisExplanation;
};

export interface RecognizedMetadata {
  /** Name of recognizer that made the decision */
  recognizer_name?: string;
}

export interface RecognizerResult {
  /** Where the PII starts */
  start: number;
  /** Where the PII ends */
  end: number;
  /** The PII detection score */
  score: number;
  entity_type: EntityTypes;
  recognition_metadata?: RecognizedMetadata;
}

export type RecognizerResultWithAnaysisExplanation = RecognizerResult & RecognizerResultWithAnaysisExplanationAllOf;

/**
 * Object where the key is DEFAULT or the ENTITY_TYPE and the value is decrypt since it is the only one supported
 */
export type DeanonymizeRequestDeanonymizers = {[key: string]: Decrypt};

export interface DeanonymizeRequest {
  /** The anonymized text */
  text: string;
  /** Object where the key is DEFAULT or the ENTITY_TYPE and the value is decrypt since it is the only one supported */
  deanonymizers: DeanonymizeRequestDeanonymizers;
  /** Array of anonymized PIIs */
  anonymizer_results: OperatorResult[];
}

/**
 * Object where the key is DEFAULT or the ENTITY_TYPE and the value is the anonymizer definition
 */
export type AnonymizeRequestAnonymizers = {[key: string]: Replace | Redact | Mask | Hash | Encrypt};

export interface AnonymizeRequest {
  /** The text to anonymize */
  text: string;
  /** Object where the key is DEFAULT or the ENTITY_TYPE and the value is the anonymizer definition */
  anonymizers?: AnonymizeRequestAnonymizers;
  /** Array of analyzer detections */
  analyzer_results: RecognizerResult[];
}

export interface AnalyzeRequest {
  /** The text to analyze */
  text: string;
  /** Two characters for the desired language in ISO_639-1 format */
  language: string;
  /** A correlation id to append to headers and traces */
  correlation_id?: string;
  /** The minimal detection score threshold */
  score_threshold?: number;
  /** A list of entities to analyze */
  entities?: EntityTypes[];
  /** Whether to include analysis explanation in the response */
  return_decision_process?: boolean;
  /** list of recognizers to be used in the context of this request only (ad-hoc). */
  ad_hoc_recognizers?: PatternRecognizer[];
  /** list of context words which may help to raise recognized entities confidence */
  context?: string[];
}




/**
 * Recognizes PII entities in a given text and returns their types, locations and score
 * @summary Analyze Text
 */
export const postAnalyze = (
    analyzeRequestBody: AnalyzeRequestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RecognizerResultWithAnaysisExplanation[]>> => {
    return axios.post(
      `/analyze`,
      analyzeRequestBody,options
    );
  }



export const getPostAnalyzeMutationOptions = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAnalyze>>, TError,{data: AnalyzeRequestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAnalyze>>, TError,{data: AnalyzeRequestBody}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAnalyze>>, {data: AnalyzeRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  postAnalyze(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PostAnalyzeMutationResult = NonNullable<Awaited<ReturnType<typeof postAnalyze>>>
    export type PostAnalyzeMutationBody = AnalyzeRequestBody
    export type PostAnalyzeMutationError = AxiosError<unknown>

    export const usePostAnalyze = <TError = AxiosError<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAnalyze>>, TError,{data: AnalyzeRequestBody}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPostAnalyzeMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get the available PII recognizers for a given language
 * @summary Get Recognizers
 */
export const getRecognizers = (
    params?: GetRecognizersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    return axios.get(
      `/recognizers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRecognizersQueryKey = (params?: GetRecognizersParams,) => [`/recognizers`, ...(params ? [params]: [])] as const;
  

    
export const getGetRecognizersQueryOptions = <TData = Awaited<ReturnType<typeof getRecognizers>>, TError = AxiosError<unknown>>(params?: GetRecognizersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRecognizers>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getRecognizers>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecognizersQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecognizers>>> = ({ signal }) => getRecognizers(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetRecognizersQueryResult = NonNullable<Awaited<ReturnType<typeof getRecognizers>>>
export type GetRecognizersQueryError = AxiosError<unknown>

export const useGetRecognizers = <TData = Awaited<ReturnType<typeof getRecognizers>>, TError = AxiosError<unknown>>(
 params?: GetRecognizersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRecognizers>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRecognizersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * Get the list of PII entities Presidio-Analyzer is capable of detecting
 * @summary Get supported entities
 */
export const getSupportedentities = (
    params?: GetSupportedentitiesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EntityTypes[]>> => {
    return axios.get(
      `/supportedentities`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetSupportedentitiesQueryKey = (params?: GetSupportedentitiesParams,) => [`/supportedentities`, ...(params ? [params]: [])] as const;
  

    
export const getGetSupportedentitiesQueryOptions = <TData = Awaited<ReturnType<typeof getSupportedentities>>, TError = AxiosError<unknown>>(params?: GetSupportedentitiesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupportedentities>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getSupportedentities>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupportedentitiesQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupportedentities>>> = ({ signal }) => getSupportedentities(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetSupportedentitiesQueryResult = NonNullable<Awaited<ReturnType<typeof getSupportedentities>>>
export type GetSupportedentitiesQueryError = AxiosError<unknown>

export const useGetSupportedentities = <TData = Awaited<ReturnType<typeof getSupportedentities>>, TError = AxiosError<unknown>>(
 params?: GetSupportedentitiesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSupportedentities>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSupportedentitiesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Anonymize Text
 */
export const postAnonymize = (
    anonymizeRequestBody: AnonymizeRequestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnonymizeResponse>> => {
    return axios.post(
      `/anonymize`,
      anonymizeRequestBody,options
    );
  }



export const getPostAnonymizeMutationOptions = <TError = AxiosError<InlineResponse400 | InlineResponse422>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAnonymize>>, TError,{data: AnonymizeRequestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAnonymize>>, TError,{data: AnonymizeRequestBody}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAnonymize>>, {data: AnonymizeRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  postAnonymize(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PostAnonymizeMutationResult = NonNullable<Awaited<ReturnType<typeof postAnonymize>>>
    export type PostAnonymizeMutationBody = AnonymizeRequestBody
    export type PostAnonymizeMutationError = AxiosError<InlineResponse400 | InlineResponse422>

    export const usePostAnonymize = <TError = AxiosError<InlineResponse400 | InlineResponse422>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAnonymize>>, TError,{data: AnonymizeRequestBody}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPostAnonymizeMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get supported anonymizers
 */
export const getAnonymizers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    return axios.get(
      `/anonymizers`,options
    );
  }


export const getGetAnonymizersQueryKey = () => [`/anonymizers`] as const;
  

    
export const getGetAnonymizersQueryOptions = <TData = Awaited<ReturnType<typeof getAnonymizers>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAnonymizers>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getAnonymizers>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAnonymizersQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAnonymizers>>> = ({ signal }) => getAnonymizers({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetAnonymizersQueryResult = NonNullable<Awaited<ReturnType<typeof getAnonymizers>>>
export type GetAnonymizersQueryError = AxiosError<unknown>

export const useGetAnonymizers = <TData = Awaited<ReturnType<typeof getAnonymizers>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAnonymizers>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAnonymizersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Deanonymize Text
 */
export const postDeanonymize = (
    deanonymizeRequestBody: DeanonymizeRequestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeanonymizeResponse>> => {
    return axios.post(
      `/deanonymize`,
      deanonymizeRequestBody,options
    );
  }



export const getPostDeanonymizeMutationOptions = <TError = AxiosError<InlineResponse400 | InlineResponse422>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postDeanonymize>>, TError,{data: DeanonymizeRequestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postDeanonymize>>, TError,{data: DeanonymizeRequestBody}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postDeanonymize>>, {data: DeanonymizeRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  postDeanonymize(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PostDeanonymizeMutationResult = NonNullable<Awaited<ReturnType<typeof postDeanonymize>>>
    export type PostDeanonymizeMutationBody = DeanonymizeRequestBody
    export type PostDeanonymizeMutationError = AxiosError<InlineResponse400 | InlineResponse422>

    export const usePostDeanonymize = <TError = AxiosError<InlineResponse400 | InlineResponse422>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postDeanonymize>>, TError,{data: DeanonymizeRequestBody}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPostDeanonymizeMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get supported deanonymizers
 */
export const getDeanonymizers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    return axios.get(
      `/deanonymizers`,options
    );
  }


export const getGetDeanonymizersQueryKey = () => [`/deanonymizers`] as const;
  

    
export const getGetDeanonymizersQueryOptions = <TData = Awaited<ReturnType<typeof getDeanonymizers>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeanonymizers>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getDeanonymizers>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDeanonymizersQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDeanonymizers>>> = ({ signal }) => getDeanonymizers({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetDeanonymizersQueryResult = NonNullable<Awaited<ReturnType<typeof getDeanonymizers>>>
export type GetDeanonymizersQueryError = AxiosError<unknown>

export const useGetDeanonymizers = <TData = Awaited<ReturnType<typeof getDeanonymizers>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDeanonymizers>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDeanonymizersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Healthcheck
 */
export const getHealth = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    return axios.get(
      `/health`,options
    );
  }


export const getGetHealthQueryKey = () => [`/health`] as const;
  

    
export const getGetHealthQueryOptions = <TData = Awaited<ReturnType<typeof getHealth>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHealthQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealth>>> = ({ signal }) => getHealth({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getHealth>>>
export type GetHealthQueryError = AxiosError<unknown>

export const useGetHealth = <TData = Awaited<ReturnType<typeof getHealth>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetHealthQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


